\documentclass[a4paper, 11pt, fleqn, twoside]{scrreprt}
% escapeinside
%\usepackage[gray]{xcolor}
\usepackage[T1]{fontenc}        % T1-Fonts
\usepackage[utf8]{inputenc}     % Enkodierung
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{proof} % 
%%http://www.logicmatters.net/resources/ndexamples/proofsty.html
%\usepackage{bussproofs}
\usepackage{hyperref}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{natbib}
\usepackage[automark, headsepline]{scrlayer-scrpage}

% Kapitelüberschrift in der Kopfzeile
%\usepackage[automark]{scrpage2} % Schickerer Satzspiegel mit KOMA-Script
%\pagestyle{scrheadings}

% Minted
\usepackage{minted}
\usemintedstyle[Haskell]{trac, fontsize=\small}%,frame=lines, framesep=10pt}
\setmintedinline{style = bw}

% Für schönere Tabellen (optional)
% \usepackage{booktabs}           % Netteres Tabellenlayout
% \usepackage{multicol}           % Mehrspaltige Bereiche
% \usepackage{tabularx}           % Tabellen mit fester Breite

% Für Listings
% \usepackage{listings}

% Eine kleine Hilfe für offene Lücken
\newcommand{\todo}[1]{\marginpar{\textbf{TODO:} #1}}
\newcommand{\coqinline}[1]{\mintinline{coq}{#1}}

\begin{document}

\pagenumbering{roman} % römische Seitenzahlen

\begin{titlepage}
	\vspace*{3cm}
	\centering
	{\huge\bfseries Modelling Call-Time Choice as Effect using Scoped Free 
	Monads\par}
	\vspace{1cm}
	\textbf{Niels Bunkenburg} \par 
	\vspace{6cm}
	\textbf{Master's Thesis} \par
	Programming Languages and Compiler Construction \par
	Department of Computer Science \par
	Kiel University
	\vfill
	Advised by\par
	Priv.-Doz. Dr. Frank Huch \par
	M. Sc. Sandra Dylus
	\vfill
	% Randloses Drucken nicht möglich...
	\tikz[remember picture,overlay] \node[opacity=0.3,inner sep=0pt] at 
	(9.5,-1.5){\includegraphics{img/cau-siegel-1400.png}};
	{\large \today\par}
\end{titlepage}

\chapter*{Erklärung der Urheberschaft}
\vspace{2cm}
Ich erkläre hiermit an Eides statt, dass ich die vorliegende Arbeit
ohne Hilfe Dritter und ohne Benutzung anderer als der angegebenen
Hilfsmittel angefertigt habe. Aus fremden Quellen direkt oder
indirekt übernommene Gedanken sind als solche kenntlich gemacht. Die
Arbeit wurde bisher in gleicher oder ähnlicher Form in keiner anderen
Prüfungsbehörde vorgelegt und auch noch nicht veröffentlicht.

\vspace{4cm}
\hspace{1cm} $\overline{~~~~~~~~~~\mbox{Ort, Datum}~~~~~~~~~~}$ \hfill $\overline{~~~~~~~~~~~~~\mbox{Unterschrift}~~~~~~~~~~~~~}$ \hspace{1cm}

\newpage
\mbox{}
\thispagestyle{empty}
\newpage

% Verzeichnisse
\renewcommand{\contentsname}{Contents}
\tableofcontents   % Inhaltsverzeichnis
%\listoffigures     % Abbildungsverzeichnis
% \listoftables      % Tabellenverzeichnis
% \lstlistoflistings % Abbildungsverzeichnis

\newpage               % Expliziter Umbruch für Seitenzahlen
\pagenumbering{arabic} % arabische Seitenzahlen

% Inhalt

\chapter{Introduction}

\chapter{Preliminaries}

\section{Coq}

\section{Haskell}

\section{Curry}
\subsection{Non-strictness}
\subsection{Sharing}
\subsection{Non-determinism}

\section{Modelling Curry Programs using Monadic Code Transformation}
Modelling Curry programs in a language like Haskell requires a transformation 
of non-deterministic code into a semantically equivalent, deterministic 
program. First, we have a look at the direct representation of non-determinism 
used in the KiCS2 implementation as described by \citet{KiCS2-NewCompiler}.

Non-determinism in Curry is not limited to \textit{flat} non-determinism but 
can occur within components of data structures and anywhere in a computation. 
This means that expressing non-determinism via Haskell's list monad is not 
sufficient to model Curry's non-determinism. \todo{Example}
Instead, existing data types receive additional constructors that represent 
failure and the choice between two values. For example, the extended list data 
type looks as follows.

\begin{minted}{Haskell}
data List a = Nil | Cons a (List a) | Choice (List a) (List a) | Fail
\end{minted}

Since this transformation adds new constructors, all functions need to cover 
these cases, too. The new rules return \mintinline{Haskell}{Fail} if the 
function's argument is a failed computation and distribute function calls to 
both branches if the argument is a choice.

One issue with this approach is that call-time choice is not implemented yet. 
If a choice is duplicated during evaluation, this information cannot be 
recovered later. Therefore, each \mintinline{Haskell}{Choice} constructor has 
an additional \mintinline{Haskell}{ID} argument that identifies the same 
choices. Since each choice needs a fresh ID, functions use an additional 
\mintinline{Haskell}{IDSupply} argument when choices are created.

The evaluation of a non-deterministic value is implemented by transforming the 
value into a search tree which can be traversed with different search 
strategies. In the process, each choice ID's decision is stored and then 
repeated if the same ID is encountered again.

While this approach is useful when the host language supports laziness and 
sharing, another approach is necessary to model these effects when they are not 
built into the language. 

\citet{PurelyFunctional} introduce a monadic representation of non-determinism 
that supports sharing and non-strict evaluation. Out of simplicity, the 
implementation idea is presented in Haskell, similar to the approach of the 
original authors.

As mentioned before, modelling non-determinism in Haskell requires us to adapt 
data types so that components can contain non-determinism because 
non-strictness is lost. \todo{Copy examples? New examples? No examples?}

\begin{minted}{Haskell}
data List m a = Nil | Cons (m a) (m (List m a))
\end{minted}

The list data type now has an additional argument \mintinline{Haskell}{m} of 
type \mintinline{Haskell}{* -> *} that represents a non-determinism monad. 
Instead of fixed constructors like \mintinline{Haskell}{Choice}, the monad 
\mintinline{Haskell}{m} determines the structure and evaluation strategy 
of the non-determinism effect.

Data types with non-deterministic components solve the problem of 
non-strictness because each component can be evaluated individually, instead of 
forcing the evaluation of the whole term. Unfortunately, this leads to a 
problem. When unevaluated components are shared via Haskell's built-in sharing, 
computations, rather than results, are being shared. This means that the 
results can be different, which contradicts the intuition of sharing.

The solution to this problem is an explicit sharing combinator 
\mintinline{Haskell}{share :: m a -> m (m a)} that allows sharing the results 
of a computation in a non-strict way. Here, \mintinline{Haskell}{m} is a 
\mintinline{Haskell}{MonadPlus} instance, similar to the monad used in the 
definition of the data type. Thus, \mintinline{Haskell}{share} takes a 
computation and then returns a computation that returns the result, that is, 
the shared value. The reason for this nesting of monad layers is that, in 
short, the \mintinline{Haskell}{share} combinator performs some actions that 
can be immediately executed by bind (the outer monad layer), while the inner 
monad layer should only be evaluated. This will be explained in more detail 
later.
\chapter{Call-Time Choice modelled in Haskell}

\section{Free Monads}

\section{Modelling Effects}

\section{Sharing}

\chapter{Call-Time Choice modelled in Coq}

\chapter{Conclusion}


% Literatur
\bibliographystyle{plainnat}
\bibliography{Mathesis} % Datei: seminar.bib
% Anhang
\appendix
\end{document}