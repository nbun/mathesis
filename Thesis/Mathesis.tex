\documentclass[a4paper, 11pt, fleqn, twoside]{scrreprt}
% escapeinside
%\usepackage[gray]{xcolor}
\usepackage[T1]{fontenc}        % T1-Fonts
\usepackage[utf8]{inputenc}     % Enkodierung
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{proof} % 
%%http://www.logicmatters.net/resources/ndexamples/proofsty.html
%\usepackage{bussproofs}
\usepackage{hyperref}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{natbib}
\usepackage{abstract}
\usepackage[automark, headsepline]{scrlayer-scrpage}

% Kapitelüberschrift in der Kopfzeile
%\usepackage[automark]{scrpage2} % Schickerer Satzspiegel mit KOMA-Script
%\pagestyle{scrheadings}

% Minted
\usepackage{minted}
\usemintedstyle[Haskell]{trac, fontsize=\small}%,frame=lines, framesep=10pt}
\setmintedinline{style = bw}

% Für schönere Tabellen (optional)
% \usepackage{booktabs}           % Netteres Tabellenlayout
% \usepackage{multicol}           % Mehrspaltige Bereiche
% \usepackage{tabularx}           % Tabellen mit fester Breite

% Für Listings
% \usepackage{listings}

% Eine kleine Hilfe für offene Lücken
\newcommand{\todo}[1]{\marginpar{\textbf{TODO:} #1}}
\newcommand{\coqinline}[1]{\mintinline{coq}{#1}}

\begin{document}

\pagenumbering{roman} % römische Seitenzahlen

\begin{titlepage}
	\vspace*{3cm}
	\centering
	{\huge\bfseries Modelling Call-Time Choice as Effect using Scoped Free 
	Monads\par}
	\vspace{1cm}
	\textbf{Niels Bunkenburg} \par 
	\vspace{6cm}
	\textbf{Master's Thesis} \par
	Programming Languages and Compiler Construction \par
	Department of Computer Science \par
	Kiel University
	\vfill
	Advised by\par
	Priv.-Doz. Dr. Frank Huch \par
	M. Sc. Sandra Dylus
	\vfill
	% Randloses Drucken nicht möglich...
	\tikz[remember picture,overlay] \node[opacity=0.3,inner sep=0pt] at 
	(9.5,-1.5){\includegraphics{img/cau-siegel-1400.png}};
	{\large \today\par}
\end{titlepage}

\newpage
\thispagestyle{empty}
\strut
\newpage

\chapter*{Erklärung der Urheberschaft}
\vspace{2cm}
Ich erkläre hiermit an Eides statt, dass ich die vorliegende Arbeit
ohne Hilfe Dritter und ohne Benutzung anderer als der angegebenen
Hilfsmittel angefertigt habe. Aus fremden Quellen direkt oder
indirekt übernommene Gedanken sind als solche kenntlich gemacht. Die
Arbeit wurde bisher in gleicher oder ähnlicher Form in keiner anderen
Prüfungsbehörde vorgelegt und auch noch nicht veröffentlicht.

\vspace{4cm}
\hspace{1cm} $\overline{~~~~~~~~~~\mbox{Ort, Datum}~~~~~~~~~~}$ \hfill $\overline{~~~~~~~~~~~~~\mbox{Unterschrift}~~~~~~~~~~~~~}$ \hspace{1cm}

\newpage
\mbox{}
\thispagestyle{empty}
\newpage

\begin{abstract}

\end{abstract}

\newpage
\strut
\thispagestyle{empty}
\newpage

% Verzeichnisse
\renewcommand{\contentsname}{Contents}
\tableofcontents   % Inhaltsverzeichnis
%\listoffigures     % Abbildungsverzeichnis
% \listoftables      % Tabellenverzeichnis
% \lstlistoflistings % Abbildungsverzeichnis

\newpage               % Expliziter Umbruch für Seitenzahlen
\pagenumbering{arabic} % arabische Seitenzahlen

% Inhalt

\chapter{Introduction}

\chapter{Preliminaries}

\section{Coq}
\label{coq-intro}
\begin{itemize}
\item Introduce the necessary Coq concepts to understand the paper
\end{itemize}

\section{Haskell}
\begin{itemize}
\item Introduce the necessary Haskell concepts to understand the paper
\end{itemize}
\subsection{Monad and MonadPlus}

\section{Curry}
\begin{itemize}
\item Introduce the necessary Curry concepts to understand the paper
\end{itemize}
\subsection{Non-strictness}
\subsection{Sharing}
\subsection{Non-determinism}

\section{Modelling Curry Programs using Monadic Code Transformation}
\begin{itemize}
\item Why is the naive MonadPlus approach not sufficient to model Curry 
semantic?
\item Motivate usage of monadic data types
\item Introduce explicit sharing
\end{itemize}

Modelling Curry programs in a language like Haskell requires a transformation 
of non-deterministic code into a semantically equivalent, deterministic 
program. First, we have a look at the direct representation of non-determinism 
used in the KiCS2 implementation as described by \citet{KiCS2-NewCompiler}.

Non-determinism in Curry is not limited to \textit{flat} non-determinism but 
can occur within components of data structures and anywhere in a computation. 
This means that expressing non-determinism via Haskell's list monad is not 
sufficient to model Curry's non-determinism. \todo{Example}
Instead, existing data types receive additional constructors that represent 
failure and the choice between two values. For example, the extended list data 
type looks as follows.

\begin{minted}{Haskell}
data List a = Nil | Cons a (List a) | Choice (List a) (List a) | Fail
\end{minted}

Since this transformation adds new constructors, all functions need to cover 
these cases, too. The new rules return \mintinline{Haskell}{Fail} if the 
function's argument is a failed computation and distribute function calls to 
both branches if the argument is a choice.

One issue with this approach is that call-time choice is not implemented yet. 
If a choice is duplicated during evaluation, this information cannot be 
recovered later. Therefore, each \mintinline{Haskell}{Choice} constructor has 
an additional \mintinline{Haskell}{ID} argument that identifies the same 
choices. Since each choice needs a fresh ID, functions use an additional 
\mintinline{Haskell}{IDSupply} argument when choices are created.

The evaluation of a non-deterministic value is implemented by transforming the 
value into a search tree which can be traversed with different search 
strategies. In the process, each choice ID's decision is stored and then 
repeated if the same ID is encountered again.

While this approach is useful when the host language supports laziness and 
sharing, another approach is necessary to model these effects when they are not 
built into the language. 

\citet{PurelyFunctional} introduce a monadic representation of non-determinism 
that supports sharing and non-strict evaluation. Out of simplicity, the 
implementation idea is presented in Haskell, similar to the approach of the 
original authors, using the example of permutation sort.
The algorithm consists  of three components. Firstly, a function 
\mintinline{Haskell}{insert} that inserts an element non-deterministically at 
every possible position within a list.

\begin{minted}{Haskell}
insert :: MonadPlus m => a -> [a] -> m [a]
insert x xs = return (x:xs)
      `mplus` case xs of
                []     -> mzero
                (y:ys) -> do zs <- insert x ys
                             return (y:zs)
\end{minted}

The second part is the function \mintinline{Haskell}{perm} that inserts the 
head of a given list into the permutations of the list's tail.
\begin{minted}{Haskell}
perm :: MonadPlus m => [a] -> m [a]
perm [] = return []
perm (x:xs) = do ys <- perm xs
                 zs <- insert x ys
                 return zs
\end{minted}

Finally, the function \mintinline{Haskell}{sort} generates permutations and 
then tests whether they are sorted.

\begin{minted}{Haskell}
sort :: MonadPlus m => [Int] -> m [Int]
sort xs = do ys <- perm xs
             guard (isSorted ys)
             return ys
\end{minted}

The function \mintinline{Haskell}{isSorted} compares each element in a list to 
the next one to determine whether the list is sorted. When we test this 
implementation, we can see that the runtime increases significantly when adding 
even a few elements.

\begin{minted}{Haskell}
*Test> sort [1..9] :: [[Int]]
[[1,2,3,4,5,6,7,8,9]]
(0.69 secs, 717,914,784 bytes)
*Test> sort [1..10] :: [[Int]]
[[1,2,3,4,5,6,7,8,9,10]]
(6.67 secs, 7,437,960,280 bytes)
*Test> sort [1..11] :: [[Int]]
[[1,2,3,4,5,6,7,8,9,10,11]]
(77.54 secs, 84,743,416,080 bytes)
\end{minted}

The reason for the factorial runtime is non-strictness. A list of length $n$ 
has $n!$ permutations, all of which are generated when running 
\mintinline{Haskell}{sort}. This matches our observation above, since adding a 
tenth element increases the runtime by a factor of 10 and an eleventh element 
multiplies the runtime of the ten-element list by eleven. 

Since our algorithm applies the generate and test paradigm, is the former or 
the latter component too strict? If we consider the implementation of 
\mintinline{Haskell}{isSorted}, we can see that, as soon as the comparison of 
two elements yields \mintinline{Haskell}{False}, the function returns 
\mintinline{Haskell}{False} and does not evaluate the remainder of the list.

\begin{minted}{Haskell}
isSorted :: [Int] -> Bool
isSorted (x:y:zs) = (x <= y) && isSorted (y:zs)
isSorted _        = True
\end{minted}

Therefore the \textit{test} part of our implementation is not the culprit of 
the non-strictness. Generating the elements is not strict either, as evidenced 
by taking only a few elements from the list of permutations of length eleven.

\begin{minted}{Haskell}
*Test> take 2 (perm [1..10])
[[1,2,3,4,5,6,7,8,9,10],[2,1,3,4,5,6,7,8,9,10]]
(0.01 secs, 103,208 bytes)
\end{minted}

Thus, only the function that combines \mintinline{Haskell}{perm} and 
\mintinline{Haskell}{isSorted}, that is, the bind operator 
\mintinline{Haskell}{>>=}, remains.

As mentioned before, modelling non-determinism in Haskell requires us to adapt 
data types so that components can contain non-determinism because otherwise
non-strictness is lost. \todo{Copy examples? New examples? No examples?}

\begin{minted}{Haskell}
data List m a = Nil | Cons (m a) (m (List m a))
\end{minted}

The list data type now has an additional argument \mintinline{Haskell}{m} of 
type \mintinline{Haskell}{* -> *} that represents a non-determinism monad. 
Instead of fixed constructors like \mintinline{Haskell}{Choice}, the monad 
\mintinline{Haskell}{m} determines the structure and evaluation strategy 
of the non-determinism effect.

Data types with non-deterministic components solve the problem of 
non-strictness because each component can be evaluated individually, instead of 
forcing the evaluation of the whole term. Unfortunately, this leads to a 
problem. When unevaluated components are shared via Haskell's built-in sharing, 
computations, rather than results, are being shared. This means that the 
results can be different, which contradicts the intuition of sharing.

The solution to this problem is an explicit sharing combinator 
\mintinline{Haskell}{share :: m a -> m (m a)} that allows sharing the results 
of a computation in a non-strict way. Here, \mintinline{Haskell}{m} is a 
\mintinline{Haskell}{MonadPlus} instance, similar to the monad used in the 
definition of the data type. Thus, \mintinline{Haskell}{share} takes a 
computation and then returns a computation that returns the result, that is, 
the shared value. The reason for this nesting of monad layers is that, in 
short, the \mintinline{Haskell}{share} combinator performs some actions that 
can be immediately executed by bind (the outer monad layer), while the inner 
monad layer should only be evaluated. This will be explained in more detail 
later.
\chapter{Call-Time Choice modelled in Haskell}

\section{Free Monads}
\begin{itemize}
\item What are free monads?
\item Why do we use free monads?
\end{itemize}

\section{Modelling Effects}
\begin{itemize}
\item Explanation of the Prog/sig infrastructure
\item ND and state effect implementation 
\end{itemize}

\section{Sharing}
\begin{itemize}
\item How can we implement simple sharing as an effect?
\item What about deep/nested sharing?
\item Examples (exRecList, ...)
\end{itemize}


\chapter{Call-Time Choice modelled in Coq}
The goal of this chapter is to transfer the Haskell implementation of call-time 
choice to Coq. We begin with the data structure \mintinline{Haskell}{Prog}, 
that is, the free monad, which allowed us to model programs with effects of 
type \mintinline{Haskell}{sig} and results of type \mintinline{Haskell}{a}.

\begin{minted}{Haskell}
data Prog sig a = Return a | Op (sig (Prog sig a))
\end{minted}

The definition in Coq looks very similar to the Haskell version, aside from 
renaming and the explicit constructor types.

\begin{minted}{Coq}
Inductive Free F A :=
| pure : A -> Free F A
| impure : F (Free F A) -> Free F A.
\end{minted}

However, the definition is rejected by Coq upon loading the file with the 
following error message.

\begin{minted}{Text}
Non-strictly positive occurrence of "Free" in "F (Free F A) -> Free F A".
\end{minted}

The reason for this error is explained in the next section.

\section{Non-strictly Positive Occurrence}
\begin{itemize}
\item What does non-strictly positive occurrence mean?
\item Motivation for usage of containers
\end{itemize}

In \autoref{coq-intro}, we learned that Coq distinguishes between 
non-recursive definitions and functions that use recursion. The reason for this 
is that Coq checks functions for termination, which is an important part of 
Coq's proof logic. To understand why functions must always terminate in Coq, we 
consider the following function.

% https://www.di.ens.fr/~zappa/teaching/coq/ecole11/summer/lectures/lec9.pdf
\begin{minted}{Coq}
Fail Fixpoint loop (x : unit) : A := loop x.
\end{minted}

The function receives an argument \mintinline{Coq}{x} and calls itself with the 
same argument. Since this function obviously never terminates, the result type 
\mintinline{Coq}{A} is arbitrary. In particular, we could instantiate 
\mintinline{Coq}{A} with \mintinline{Coq}{False}, the false proposition. The 
value \mintinline{Coq}{loop tt : False} could be used to prove anything,
according to the principle of explosion. For this reason, Coq requires all 
recursive functions to terminate provably.

Returning to the original data type, what is link between 
\mintinline{Coq}{Free} and termination? It is well known that recursion can be 
implemented in languages without explicit recursion syntax by means of 
constructs like the Y combinator or the data type \mintinline{Coq}{Mu} for 
type-level recursion.

\begin{minted}{Coq}
Fail Inductive Mu A := mu : (Mu A -> A) -> Mu A.
\end{minted}

\mintinline{Coq}{Mu} is not accepted by Coq for the same reason as 
\mintinline{Coq}{Free}: non-strictly positive occurrence of the respective data 
type. The problematic property of non-strictly positive data types is that the 
type occurs on the left-hand side of a constructor argument's function type. 
This would allow general recursion and thus, as described above, make Coq's 
logic inconsistent.

In case of \mintinline{Coq}{Free}, the non-strictly positive occurrence is not 
as apparent as before because the constructors do not have functional 
arguments. However, \mintinline{Coq}{F} is being applied to 
\mintinline{Coq}{Free F A}. If \mintinline{Coq}{F} has a functional argument 
with appropriate types, the resulting type becomes non-strictly positive, as 
shown below.

\begin{minted}{Coq}
Definition Cont R A := (A -> R) -> R.

(* Free (Cont R) *)
Fail Inductive ContF R A :=
| pureC   : A -> ContF R A
| impureC : ((ContF R A -> R) -> R) -> ContF R A.
\end{minted}

In the type of \mintinline{Coq}{impureC} contains a non-strictly positive 
occurrence of \mintinline{Coq}{ContF R A}. Consequently, Coq rejects 
\mintinline{Coq}{Free} because it is not guaranteed that no instance violates 
the strict positivity requirement. Representing the \mintinline{Coq}{Free} data 
type therefore requires a way to restrict the definition to strictly positive 
data types. One approach to achieve this goal is described in the next section.

\section{Containers}

\begin{itemize}
\item How do containers work?
\item How do we translate effect functors into containers?
\end{itemize}

Containers are an abstraction of data types that store values, with the 
property that only strictly positive data types can be modelled as a container. 
This will allow us to define a version of \mintinline{Coq}{Free} that works 
with containers of type constructors instead of the type constructors itself. 
First, however, we will have a more detailed look at containers.

The first component of a container is the type \mintinline{Coq}{Shape}. A 
shape determines how the data type is structured, regardless of the stored 
values. For example, the  shape of a list is the same as the shape of Peano 
numbers: a number that  represents the length of the list, or rather the number 
of \mintinline{Haskell}{Cons}/\mintinline{Haskell}{Succ} applications. A pair, 
on the other hand, has only a single shape.

The second component of a container is a function \mintinline{Coq}{Pos : Shape 
-> Type} that gives each shape a type that represents the positions within the 
shape. In the example of pairs, the shape has two positions, the first and 
second component. Each element of a list is a position within the shape. 
Therefore, the position type for lists with length $n$ is natural numbers 
smaller than $n$. Peano numbers do not have elements and therefore, the 
position type for each shape is empty.

Containers can be extended by a function that maps all valid positions to 
values. Since the position type depends on a concrete shape, the definition in 
Coq is quantified universally over values of type \mintinline{Coq}{Shape}.

\begin{minted}{Coq}
Inductive Ext Shape (Pos : Shape -> Type) A := 
  ext : forall s, (Pos s -> A) -> Ext Shape Pos A.
\end{minted}

The extension of a container models the concrete data type.

\section{Modelling Effects}
\begin{itemize}
\item In which ways is the Coq implementation simplified, compared to Haskell?
\item How does the adapted Prog/sig infrastructure work?
\item How do we translate recursive functions?
\end{itemize}

\section{Sharing}
\begin{itemize}
\item Laws of sharing
\end{itemize}

\chapter{Curry Programs modelled in Coq}
\begin{itemize}
\item Can we use the Coq model of call-time choice to prove properties about 
actual Curry programs?
\end{itemize}

\chapter{Conclusion}


% Literatur
\bibliographystyle{plainnat}
\bibliography{Mathesis} % Datei: seminar.bib
% Anhang
\appendix
\end{document}