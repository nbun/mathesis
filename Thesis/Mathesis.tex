% !TEX TS-program = lualatex
\documentclass[a4paper, 11pt, fleqn, twoside]{scrreprt}
% escapeinside
%\usepackage[gray]{xcolor}
\usepackage[T1]{fontenc}        % T1-Fonts
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{proof} % 
%%http://www.logicmatters.net/resources/ndexamples/proofsty.html
%\usepackage{bussproofs}
\usepackage{hyperref}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{natbib}
\usepackage{abstract}
\usepackage[automark, headsepline]{scrlayer-scrpage}

% Kapitelüberschrift in der Kopfzeile
%\usepackage[automark]{scrpage2} % Schickerer Satzspiegel mit KOMA-Script
%\pagestyle{scrheadings}

% Minted
\usepackage{fontspec}

\setmonofont{Fira Code Regular}
\setmainfont{XCharter Roman}
\newfontfamily{\fallbackfont}{Source Code Pro}[Scale=MatchLowercase]
\DeclareTextFontCommand{\textfallback}{\fallbackfont}

\usepackage{newunicodechar}
\newunicodechar{∀}{\textfallback{∀}}
\newunicodechar{≔}{:=}

\usepackage{minted}
\usemintedstyle[Haskell]{trac, fontsize=\small}
\usemintedstyle[Coq]{default, encoding=utf8, fontsize=\small}
\usemintedstyle[Text]{default, fontsize=\small}
%framesep=10pt}
\setmintedinline{style = bw, fontsize=\small}

% Für schönere Tabellen (optional)
% \usepackage{booktabs}           % Netteres Tabellenlayout
% \usepackage{multicol}           % Mehrspaltige Bereiche
% \usepackage{tabularx}           % Tabellen mit fester Breite

% Für Listings
% \usepackage{listings}

% Eine kleine Hilfe für offene Lücken
\newcommand{\todo}[1]{\marginpar{\textbf{TODO:} #1}}
\newcommand{\hinl}[1]{\mintinline{Haskell}{#1}}
\newcommand{\cinl}[1]{\mintinline{Coq}{#1}}

\setlength\partopsep{-\topsep}
\addtolength\partopsep{-\parskip}
\addtolength\partopsep{0.32cm}

\begin{document}
\pagenumbering{roman} % römische Seitenzahlen

\begin{titlepage}
	\vspace*{3cm}
	\centering
	{\huge\bfseries Modelling Call-Time Choice as Effect using Scoped Free 
	Monads\par}
	\vspace{1cm}
	\textbf{Niels Bunkenburg} \par 
	\vspace{6cm}
	\textbf{Master's Thesis} \par
	Programming Languages and Compiler Construction \par
	Department of Computer Science \par
	Kiel University
	\vfill
	Advised by\par
	Priv.-Doz. Dr. Frank Huch \par
	M. Sc. Sandra Dylus
	\vfill
	% Randloses Drucken nicht möglich...
	\tikz[remember picture,overlay] \node[opacity=0.3,inner sep=0pt] at 
	(9.5,-1.5){\includegraphics{img/cau-siegel-1400.png}};
	{\large \today\par}
\end{titlepage}

\newpage
\thispagestyle{empty}
\strut
\newpage

\chapter*{Erklärung der Urheberschaft}
\vspace{2cm}
Ich erkläre hiermit an Eides statt, dass ich die vorliegende Arbeit ohne Hilfe Dritter und ohne Benutzung anderer als der angegebenen Hilfsmittel angefertigt habe. Aus fremden Quellen direkt oder indirekt übernommene Gedanken sind als solche kenntlich gemacht. Die Arbeit wurde bisher in gleicher oder ähnlicher Form in keiner anderen Prüfungsbehörde vorgelegt und auch noch nicht veröffentlicht.

\vspace{4cm}
\hspace{1cm} $\overline{~~~~~~~~~~\mbox{Ort, Datum}~~~~~~~~~~}$ \hfill $\overline{~~~~~~~~~~~~~\mbox{Unterschrift}~~~~~~~~~~~~~}$ \hspace{1cm}

\newpage
\mbox{}
\thispagestyle{empty}
\newpage

\begin{abstract}

\end{abstract}

\newpage
\strut
% This is necessary to apply the command that disables lexer errors for Unicode
\begin{minted}{Coq} 
\end{minted}

% Disable highlighting of lexer errors for Unicode
\makeatletter
\expandafter\def\csname PYGdefault@tok@err\endcsname{\def\PYGdefault@bc##1{##1}}
\makeatother

\thispagestyle{empty}
\newpage

% Verzeichnisse
\renewcommand{\contentsname}{Contents}
\tableofcontents   % Inhaltsverzeichnis
%\listoffigures     % Abbildungsverzeichnis
% \listoftables      % Tabellenverzeichnis
% \lstlistoflistings % Abbildungsverzeichnis

\newpage               % Expliziter Umbruch für Seitenzahlen
\pagenumbering{arabic} % arabische Seitenzahlen

% Inhalt

\chapter{Introduction}

\chapter{Preliminaries}

\section{Coq}
\label{sec:coqIntro}
\begin{itemize}
\item Introduce the necessary Coq concepts to understand the paper
\end{itemize}

\section{Haskell}
\begin{itemize}
\item Introduce the necessary Haskell concepts to understand the paper
\end{itemize}
\subsection{Monad and MonadPlus}

\section{Curry}
\begin{itemize}
\item Introduce the necessary Curry concepts to understand the paper
\end{itemize}
\subsection{Non-strictness}
\subsection{Sharing}
\subsection{Non-determinism}

\section{Modelling Curry Programs using Monadic Code Transformation}
\begin{itemize}
\item Why is the naive MonadPlus approach not sufficient to model Curry semantic?
\item Motivate usage of monadic data types
\item Introduce explicit sharing
\end{itemize}

Modelling Curry programs in a language like Haskell requires a transformation of non-deterministic code into a semantically equivalent, deterministic program.
First, we have a look at the direct representation of non-determinism used in the KiCS2 implementation as described by \citet{brassel2011kics2}.

Non-determinism in Curry is not limited to \textit{flat} non-determinism but can occur within components of data structures and anywhere in a computation.
This means that expressing non-determinism via Haskell's list monad is not sufficient to model Curry's non-determinism.
\todo{Example}
Instead, existing data types receive additional constructors that represent failure and the choice between two values.
For example, the extended list data type looks as follows.

\begin{minted}{Haskell}
data List a = Nil | Cons a (List a) | Choice (List a) (List a) | Fail
\end{minted}

Since this transformation adds new constructors, all functions need to cover these cases, too.
The new rules return \hinl{Fail} if the function's argument is a failed computation and distribute function calls to both branches if the argument is a choice.

One issue with this approach is that call-time choice is not implemented yet.
If a choice is duplicated during evaluation, this information cannot be recovered later.
Therefore, each \hinl{Choice} constructor has an additional \hinl{ID} argument that identifies the same choices.
Since each choice needs a fresh ID, functions use an additional \hinl{IDSupply} argument when choices are created.

The evaluation of a non-deterministic value is implemented by transforming the value into a search tree which can be traversed with different search strategies.
In the process, each choice ID's decision is stored and then repeated if the same ID is encountered again.

While this approach is useful when the host language supports laziness and sharing, another approach is necessary to model these effects when they are not built into the language.

\citet{fischer2009purely} introduce a monadic representation of non-determinism that supports sharing and non-strict evaluation.
Out of simplicity, the implementation idea is presented in Haskell, similar to the approach of the original authors, using the example of permutation sort.
The algorithm consists  of three components.
Firstly, a function \hinl{insert} that inserts an element non-deterministically at every possible position within a list.

\begin{minted}{Haskell}
insert :: MonadPlus m => a -> [a] -> m [a]
insert x xs = return (x:xs)
      `mplus` case xs of
                []     -> mzero
                (y:ys) -> do zs <- insert x ys
                             return (y:zs)
\end{minted}

The second part is the function \hinl{perm} that inserts the head of a given list into the permutations of the list's tail.

\begin{minted}{Haskell}
perm :: MonadPlus m => [a] -> m [a]
perm [] = return []
perm (x:xs) = do ys <- perm xs
                 zs <- insert x ys
                 return zs
\end{minted}

Finally, the function \hinl{sort} generates permutations and then tests whether they are sorted.

\begin{minted}{Haskell}
sort :: MonadPlus m => [Int] -> m [Int]
sort xs = do ys <- perm xs
             guard (isSorted ys)
             return ys
\end{minted}

The function \hinl{isSorted} compares each element in a list to the next one to determine whether the list is sorted.
When we test this implementation, we can see that the runtime increases significantly when adding even a few elements.

\begin{minted}{Haskell}
λ> sort [9, 8..1] :: [[Int]]
[[1,2,3,4,5,6,7,8,9]]
(0.69 secs)
λ> sort [10, 9..1] :: [[Int]]
[[1,2,3,4,5,6,7,8,9,10]]
(6.67 secs)
λ> sort [11, 10..1] :: [[Int]]
[[1,2,3,4,5,6,7,8,9,10,11]]
(77.54 secs)
\end{minted}

The reason for the factorial runtime is that the implementations is needlessly strict.
A list of length $n$  has $n!$ permutations, all of which are generated when running \hinl{sort}.
This matches our observation above, since adding a tenth element increases the runtime by a factor of 10 and an eleventh element multiplies the runtime of the ten-element list by eleven.

If we consider the implementation of \hinl{isSorted}, we can see that, as soon as the comparison of two elements yields \hinl{False}, the function returns \hinl{False} and does not evaluate the remainder of the list.

\begin{minted}{Haskell}
isSorted :: [Int] -> Bool
isSorted (x:y:zs) = (x <= y) && isSorted (y:zs)
isSorted _        = True
\end{minted}

However, since we use bind to pass permutations from \hinl{perm} to \hinl{isSorted}, each permutation is fully evaluated before it is determined whether the permutation is sorted.
This leads to the complete evaluation of every permutation, which results in an inefficient program.

Similarly, when we consider the Curry example \hinl{head (1 : head [] : [])}, the strictness of our \hinl{MonadPlus} approach shows again.
The corresponding Haskell expression is as follows.

\mint{Haskell}{hd [] >>= \x -> hd (1 : x : [])}

Here \hinl{hd :: MonadPlus a => [a] -> m a} is the lifted \hinl{head} function.
Evaluating the expression in Haskell yields \hinl{mzero}, that is, no result, while Curry returns \hinl{1}.
The reason is the definition of the bind operator.
For example, the monad instance for lists defines bind as \hinl{xs >>= f = concatMap f xs}.
In the expression above, this means that the pattern matching within \hinl{concatMap} evaluates \hinl{hd []} to \hinl{mzero} and thus returns \hinl{mzero}.

The strictness observed in both examples is the motivation for an alternative approach.
The problem with the above implementations is that non-deterministic arguments of constructors need to be evaluated completely before the computation can continue.
Therefore, we would like to be able to use unevaluated, non-deterministic computations as arguments of constructors.

As mentioned before, we can implement this idea by adapting all data types so that they may contain non-deterministic components.

\begin{minted}{Haskell}
data List m a = Nil | Cons (m a) (m (List m a))
\end{minted}

The list data type now has an additional argument \hinl{m} of type \hinl{* -> *} that represents a non-determinism monad.
Instead of fixed constructors like \hinl{Choice}, the monad \hinl{m} determines the structure and evaluation strategy of the non-determinism effect.
Two smart constructors \hinl{cons} and \hinl{nil} make handling the new list type more convenient.

\begin{minted}{Haskell}
nil :: Monad m => m (List m a)
nil = return Nil

cons :: Monad m => m a -> m (List m a) -> m (List m a)
cons x y = return (Cons x y)
\end{minted}

Adapting the permutation sort functions to the lifted data type requires us to replace \hinl{[]} with \hinl{List m} 
However, this is not sufficient because the list itself can be the result of a non-deterministic computation.
Therefore, an additional \hinl{m} is wrapped around every occurrence of \hinl{List}.

\begin{minted}{Haskell}
insert' :: MonadPlus m => m a -> m (List m a) -> m (List m a)
insert' mx mxs = cons mx mxs
  `mplus` mxs >>= \xs -> case xs of
                           Nil         -> mzero
                           Cons my mys -> cons my (insert' mx mys)

perm' :: MonadPlus m => m (List m a) -> m (List m a)
perm' ml = ml >>= \l ->
  case l of
    Nil -> nil
    Cons mx mxs -> insert' mx (perm' mxs)
\end{minted}

Whenever pattern matching occurred in the original definition, we now use bind to extract a \hinl{List} value.
Since this only evaluates flat non-determinism and not non-determinism that occurs in the components, non-strictness is upheld as much as possible.

All functions now take arguments of the same type they return.
Thus, the definition of \hinl{sort} does not need bind in order to pass permutations to \hinl{isSorted}.

\begin{minted}{Haskell}
sort' :: MonadPlus m => m (List m Int) -> m (List m Int)
sort' xs = let ys = perm' xs in
  isSorted' ys >>= \sorted -> guard sorted >> ys
\end{minted}

We are now able to take advantage of \hinl{isSorted}'s non-strict definition.
The implementation generates permutations only if there is a chance that the permutation is sorted, that is, only recursive calls of \hinl{perm} that are demanded by \hinl{isSorted} are executed.

We reconsider the Curry example \hinl{head (1 : head [] : [])}.
Since the \hinl{List} data type now takes monad values as arguments, we can write the example using the smart constructors and a lifted \hinl{head} function as follows.

\begin{minted}{Haskell}
λ> hd' (cons (return 1) (cons (hd' nil) nil))
1
\end{minted}

Because we do not need to use bind to get the result of \hinl{hd' nil}, the expression is not evaluated due to non-strictness and the result is equal to Curry's output.

Data types with non-deterministic components solve the problem of non-strictness because each component can be evaluated individually, instead of forcing the evaluation of the whole term.
Unfortunately, this leads to a problem.
When unevaluated components are shared via Haskell's built-in sharing, computations, rather than results, are being shared.
This means that the results can be different each time the computation is evaluated, which contradicts the intuition of sharing.

The solution to this problem is an explicit sharing combinator \hinl{share :: m a -> m (m a)} that allows sharing the results of a computation in a non-strict way.
Here, \hinl{m} is a \hinl{MonadPlus} instance, similar to the monad used in the definition of the data type, that supports sharing.
Thus, \hinl{share} takes a  computation and then returns a computation that returns the result, that is, the shared value.
The reason for this nesting of monad layers is that, in short, the \hinl{share} combinator performs some actions that can be immediately executed by bind (the outer monad layer), while the inner monad layer should only be evaluated when needed.
This is explained in more detail later.
With the explicit sharing operator we can adapt \hinl{perm'} to share the generated permutations in order to achieve non-strictness in combination with sharing.

\begin{minted}{Haskell}
sort' :: MonadPlus m => m (List m Int) -> m (List m Int)
sort' xs = do ys <- share (perm' xs)
              sorted <- isSorted'
              guard sorted
              ys
\end{minted}

The \hinl{share} operator must satisfy certain laws, which we discuss in \autoref{sec:lawsOfSharing}.
The implementation of \hinl{share} is subject of the next chapter.

\chapter{Call-Time Choice modelled in Haskell}
Based on the ideas presented in the last chapter, we now want to model call-time choice, that is, non-strictness, sharing and non-determinism, in Haskell.
We still use \hinl{MonadPlus} to parameterize our programs.
However, instead of, for example, using the list instance to make non-determinism visible, we define an effect functor that can express many different effects, including non-determinism and sharing.
This approach, as introduced by \citet{wu2014effect}, will also be the base of the Coq implementation shown in \autoref{ch:callTimeChoiceCoq}.
\todo{Definition effect}

For the implementation of call-time choice, we want to be able to express different effects within our programs.
However, not every program contains effects.
There are also \textit{pure} programs that have no side-effects besides the computation of a value.
A data type that represents such programs could look as follows.

\begin{minted}{Haskell}
data Void a = Return a
\end{minted}

Here, \hinl{Void} means the absence of effects.

If we consider programs that contain effects, also called \textit{impure}, like, non-determinism, a data type that represents such values could look like the following.

\begin{minted}{Haskell}
data ND a = Return a
          | Fail
          | Choice (ND a) (ND a)
\end{minted}

This data type also has a constructor to model pure values but in addition, there are constructors that represent failed computations and the non-deterministic choice between two values.
We could go on and list data types that model many more effects but the question is: Is it possible to create a data type that, if appropriately instantiated, behaves like the original effect functor?
This would allow us to represent programs with many different effects using one compact data type.

Answering this question requires abstracting the concrete form of effect functors into a general program data type.
As we saw in the examples above, we need a way to represent pure values in a program.
Therefore, the first constructor of our new program data type should be \hinl{Return a} for the type \hinl{a}, that is, the result type of the program.
To model effects like non-determinism, the program is parameterized over effect functors of type \hinl{* -> *} that represent, for example, \hinl{Fail} and \hinl{Choice}.
We call this argument \hinl{sig} because the signature of a program tells us which effects can occur.
So far, programs are defined as \hinl{data Prog sig a = Return a}.
In order do make use of the \hinl{sig} component, we need to add a constructor for impure operations.
The \hinl{ND} data type shows us that effect functors can be defined recursively.
Thus, the constructor for impure programs should be recursive, too, to be able to represent this structure.

\begin{minted}{Haskell}
data Prog sig a = Return a | Op (sig (Prog sig a))
\end{minted}

With this definition of \hinl{Prog}, we are able to represent the original functors by instantiating \hinl{sig} appropriately.
For \hinl{Void}, we already have the \hinl{Return} constructor.
Therefore, the data type we can use with \hinl{Prog} does not need a constructor anymore, that is, \hinl{data Void' a}.

\begin{minted}{Haskell}
VoidProg a = Return a
           | Op (Void' (VoidProg a)) -- Void' has no constructors!
\end{minted}

The type \hinl{Prog Void'} now resembles the original type  \hinl{Void} since the \hinl{Op} constructor  would require a value of type \hinl{Void'}, which we cannot  construct.
\footnote{It is possible to use \hinl{undefined} to create an impure value of type \hinl{Prog Void' a}.
Since this  is not possible in Coq, we do not consider this in the Haskell implementation.}
Only \hinl{Return} can be used to define values, similar to the  original data type.

Similar to \hinl{Void'}, we can define a data type  \hinl{Choice} that represents \hinl{Choice} in combination with \hinl{Prog}.

\begin{minted}{Haskell}
data ND p = Fail | Choice p p
\end{minted}

Again, we can omit the \hinl{Return} constructor because it is  already part of the \hinl{Prog} data type.
For the same reason,  the type variable \hinl{a} has been replaced with the variable \hinl{p}, since \hinl{ND} does not have values as arguments but rather programs that return values.

\begin{minted}{Haskell}
data NDProg a = Return a
              | Op (Choice (NDProg a))
\end{minted}

Since \hinl{Op} applies \hinl{sig} recursively,  this yields the following type, which is equivalent to the original data type.

\begin{minted}{Haskell}
data NDProg a = Return a
              | OpFail
              | OpChoice (NDProg a) (NDProg a)
\end{minted}

We have found a way to model effect functors as instances of the data type \hinl{Prog}, which essentially models a tree with leafs, represented by the \hinl{Return} constructor, and branches that have the form defined by \hinl{sig}.
\todo{Tree structure visualization?}

\section{Free Monads}
\begin{itemize}
\item What are free monads?
\item Why do we use free monads?
\end{itemize}

The data type \hinl{Prog} is better known as the \textit{free monad}.
We saw in the previous chapter that \hinl{Free} can be used to model other data types.
In addition, \hinl{Free} is a monad that can turn any functor into a monad.

We consider, for example, the type \hinl{Free One} where \hinl{data One a = One}.
Here \hinl{a} is a phantom type that we need because \hinl{Free} expects a functor.
The monad instance for \hinl{Free} is as follows.

\begin{minted}{Haskell}
data Free f a = Pure a | Impure (f (Free f a))

instance (Functor f, Applicative (Free f)) => Monad (Free f) where
  return = Pure
  Pure x >>= g = g x
  Impure fx >>= g = Impure (fmap (>>= g) fx)
\end{minted}

Since \hinl{One} has only a single, non-recursive constructor \hinl{One}, the only possible impure value is \hinl{Impure One}, whereas the usual \hinl{Return} constructor remains.
If bind encounters the value \hinl{One}, the function \hinl{g} is distributed deeper into the term structure using \hinl{fmap}.
Since \hinl{fmap One = One}, it becomes apparent that the monad constructed by \hinl{Free One} is the \hinl{Maybe} monad.
\todo{Visualization of fmap tree}

Since we want to model different effects in our program, the free monad makes writing programs easier by allowing monadic definitions without defining a separate monad instance for each effect.
\todo{Find more reasons for using free monads}

\section{Modelling Effects}
\begin{itemize}
\item Explanation of the Prog/sig infrastructure
\item ND and state effect implementation 
\end{itemize}

In the previous sections the free monad and its ability to represent effect functors was discussed.
The goal of this section is to explore the infrastructure that allows us to combine multiple effects, write effectful programs and compute the result of such programs.

\subsection{Combining Effects}
Firstly, we would like to combine multiple effects.
For this purpose, we use the technique introduced by \citet{swierstra2008} to define a data type that combines the effect functors \hinl{sig1} and \hinl{sig2}.
The infix notation simplifies combining multiple effects via nested applications of \hinl{:+:}.

\begin{minted}{Haskell}
data (sig1 :+: sig2) a = Inl (sig1 a) | Inr (sig2 a)
\end{minted}

For example, the type \hinl{ND :+: One} is a functor that we can use with \hinl{Prog} to define programs that contain non-determinism and partiality as follows.

\begin{minted}{Haskell}
progNDOne :: Prog (ND :+: One) Int
progNDOne = Op (Inl (Choice (Op (Inr One)) (Return 42)))
\end{minted}

In the example \hinl{progNDOne} we define a program that represents the non-deterministic choice between a program whose value is absent and a program that returns \hinl{42}.
The complexity of nesting constructors of \hinl{Prog} and \hinl{:+:} correctly increases quickly for bigger terms.
Therefore, we define a type class that allows us to define such expressions more conveniently.
The class is parameterized over two functors, one of which is a subtype -- regarding \hinl{:+:} -- of the other.

\begin{minted}{Haskell}
class (Functor sub, Functor sup) => sub :<: sup where
  inj :: sub a -> sup a
\end{minted}

We need a few instances of the class \hinl{:<:} to make it useful.
The simplest case is \hinl{sig :<: sig} where want to inject a value of type \hinl{sig a} into the same type.
Since we do not need to modify the value in any way, \hinl{id} is used to define \hinl{inj}.

\begin{minted}{Haskell}
instance Functor sig => sig :<: sig where
  inj = id  
\end{minted}

The next instance covers the case \hinl{sig1 :<: (sig1 :+: sig2)}.
Since we already know that \hinl{sig1} is part of the sum type, we only need to apply the correct constructor of \hinl{:+:}, that is, \hinl{Inl} because \hinl{sig1} is the left argument.

\begin{minted}{Haskell}
instance (Functor sig1, Functor sig2) => sig1 :<: (sig1 :+: sig2) where
  inj = Inl
\end{minted}

The last instance assumes that we can inject \hinl{sig} into \hinl{sig2} and describes how we can inject \hinl{sig} into \hinl{sig1 :+: sig2}.
In this case, we can use \hinl{inj} to receive a value of type \hinl{sig2 a}.
All that remains is a situation similar to the previous instance, where we only need to use the matching constructor to complete the injection.
 
\begin{minted}{Haskell}
instance (Functor sig1, sig :<: sig2) => sig :<: (sig1 :+: sig2) where
  inj = Inr . inj
\end{minted}

These instances allow us to write a polymorphic definition of the function \hinl{inject} which injects constructors depending on the given type of the program.

\begin{minted}{Haskell}
inject :: sig1 :<: sig2 => sig1 (Prog sig2 a) -> Prog sig2 a
inject = Op . inj
\end{minted}

\hinl{inject} can then be used as demonstrated in the following example.

\begin{minted}{Haskell}
λ> inject One :: Prog (One :+: ND) a
Op (Inl One)
λ> inject One :: Prog (ND :+: One) a
Op (Inr One)
\end{minted}

The implementation of the function \hinl{inject} assumes that we can inject \hinl{sig1} into \hinl{sig2}.
This is because \hinl{sig2} is the signature of the returned program and \hinl{sig1} is the type of the effect constructor that we want to inject.
This restriction is justified because, for example, non-deterministic syntax should only appear in a program where \hinl{ND} is part of the signature.
With this part of the infrastructure in place, we can redefine the example \hinl{progNDOne} without using \hinl{Inl} and \hinl{Inr} explicitly.

\begin{minted}{Haskell}
progNDOne' :: Prog (ND :+: One) Int
progNDOne' = inject (Choice (inject One) (Return 42))
\end{minted}

Deriving the appropriate instance of \hinl{:<:} when using \hinl{inject} is, however, not always unambiguous.
The last two instances overlap in situations where \hinl{sig = sig1}.
For example, the example \hinl{inject One :: Prog (One :+: One) a} yields different values with respect to the chosen constructor of \hinl{:<:}, depending on the instance.

\begin{minted}{Haskell}
λ> nothing
Op (Inl One) -- second instance
λ> nothing
Op (Inr One) -- third instance
\end{minted}

This is because the type constraint of \hinl{inject}, in this case \hinl{One :<: (One :+: One)}, matches both the second and third instance.
Haskell does not accept overlapping instances by default, which is why we prioritize one instance via pragmas.
In practice, the different term structure due to \hinl{Inl} and \hinl{Inr} does not influence the evaluation as long as we do not explicitly match for the constructors.
This is ensured by an additional function \hinl{prj} of the type class \hinl{:<:}, which is discussed in the next section.

\subsection{Simplified Pattern Matching}
While the function \hinl{inject} allows us to write programs in a more convenient way, we also need to consider how we can evaluate programs.
The same issue of nested applications of \hinl{Op}, \hinl{Inl} and \hinl{Inr} applies when we want to distinguish different effects via pattern matching. Thus, we add a second function \hinl{prj} to the type class \hinl{:<:}.

\begin{minted}{Haskell}
class (Functor sub, Functor sup) => sub <: sup where
  inj :: sub a -> sup a
  prj :: sup a -> Maybe (sub a)
\end{minted}

The function \hinl{prj} is a partial inverse to \hinl{inj}. 
This means that we can project values of a type \hinl{sup a} into a subtype \hinl{sub a}.
For this reason, the return type of the function is a \hinl{Maybe} type. Similar to \hinl{inj}, we have to define instances for the same cases as before. 

\begin{itemize}
\item For \hinl{sig :<: sig}, we can define \hinl{prj} as \hinl{Just} because we know that every element of the supertype is also an element the subtype.

\item \hinl{sig1 :<: (sig1 :+: sig2)} means that we can return \hinl{Just x} for \hinl{Inl x}. 
However, for \hinl{Inr} we need to return \hinl{Nothing} because we cannot, in general, project from \hinl{sig2} to \hinl{sig1}.

\item In the last case \hinl{sig :<: sig2 => sig :<: (sig1 :+: sig2)} we know that we can project from \hinl{sig2} to \hinl{sig}.
Thus, in case of \hinl{Inr x}, where \hinl{x} has the type \hinl{sig2}, we can apply \hinl{prj} to construct a value of appropriate type.
The other case \hinl{prj (Inl _)} is handled by returning \hinl{Nothing}.
\end{itemize}

With the definition of \hinl{prj} and the instances of \hinl{:<:}, we can now define the function \hinl{project} which we can use to make pattern matching more convenient.

\begin{minted}{Haskell}
project :: (sub :<: sup) => Prog sup a -> Maybe (sub (Prog sup a))
project (Op s) = prj s
project _      = Nothing
\end{minted}

Due to the recursive definition of the \hinl{Prog} data type, constructors like \hinl{Choice} have \hinl{Prog} arguments themselves.
Thus, \hinl{sub} is applied to \hinl{Prog sup a} in the return type of the projection.
We can only project effectful values because generally it is not clear which functor we should choose for \hinl{sub} when projecting a \hinl{Return} value.

Finally, we can now inject and project effectful values. Since \hinl{project} is a partial inverse of \hinl{inject}, the equation \hinl{project (inject x) = Just x} holds for values \hinl{x} of appropriate type, excluding failing computations.
\todo{Does it hold?}
This is demonstrated in the following example.

\begin{minted}{Haskell}
λ> type T = Maybe (ND (Prog (ND :+: One) Int))
λ> project (inject (Choice (Return 42) (Return 43))) :: T
Just (Choice (Return 42) (Return 43))
\end{minted}

Now that we can use \hinl{project} as an abstraction of the concrete term structure regarding \hinl{:<:}, we can write a first function that evaluates a non-deterministic, partial program.

\begin{minted}{Haskell}
evalNDOne :: Prog (ND :+: One) a -> [a]
evalNDOne (Return x) = [x]
evalNDOne p = case project p of
               Just (Choice p1 p2) -> evalNDOne p1 ++ evalNDOne p2
               Just Fail           -> []
               Nothing             -> case project p of
                                        Just One -> []
                                        Nothing  -> []
\end{minted}

When \hinl{evalNDOne} encounters a value \hinl{Return x}, \hinl{x} is returned as a singleton list. 
For effectful programs, we can use \hinl{project} to distinguish between the constructors of \textit{one effect at a time}.
The case patterns hold the necessary type information for \hinl{project}.
When the projection returns \hinl{Nothing}, another effect can be handled.
Since we never need to explicitly match for \hinl{Inl} or \hinl{Inr}, overlapping patterns in the instances of \hinl{:<:} do not affect the evaluation of programs in our model.

Although we have already eliminated \hinl{Inl}, \hinl{Inr} and \hinl{Op} from functions that create or evaluate programs, there can be done even more to simplify programming with effects.
Two language extensions, \hinl{PatternSynonyms} and \hinl{ViewPatterns}, allow us to write definitions like the following.

\begin{minted}{Haskell}
pattern PChoice p q <- (project -> Just (Choice p q))
\end{minted}

View patterns -- the right-hand side of the \hinl{<-}, make pattern-matching for certain cases more compact.
A view pattern consists of a function on the left-hand side of \hinl{->}, that is applied to the value that the pattern is matched against, and a pattern on the right-hand side.
The result of the function call is matched against this pattern and the variables inside the pattern can be used in the definition. 
The function \hinl{evalNDOne} can be defined using view patterns in the following way.

\begin{minted}{Haskell}
evalNDOne' :: Prog (ND :+: One) a -> [a]
evalNDOne' (Return x) = [x]
evalNDOne' (project -> Just (Choice p1 p2)) = evalNDOne' p1 ++ evalNDOne' p2
evalNDOne' (project -> Just Fail          ) = []
evalNDOne' (project -> Just One           ) = []
\end{minted}

We cannot use \hinl{(project -> Nothing)} without type annotations as a pattern because this would result in overlapping instances. 
However, no effects other than those specified in the signature can occur within the program. Therefore, the \hinl{Nothing} pattern is not necessary.

The second component of the pattern definition above is the option to define a synonym for more complex patterns. 
In this case, we name the view patterns similar to the original constructors of the effects. While this is necessary for every effect constructor, it allows us to rewrite the definition in the following way.

\begin{minted}{Haskell}
evalNDOne'' :: Prog (ND :+: One) a -> [a]
evalNDOne'' (Return    x) = [x]
evalNDOne'' (PChoice p q) = evalNDOne'' p ++ evalNDOne'' q
evalNDOne'' (PFail      ) = []
evalNDOne'' (POne       ) = []
\end{minted}

Writing programs that evaluate effectful programs is almost as convenient as simple pattern matching now.

\section{Sharing}
\begin{itemize}
\item How can we implement simple sharing as an effect?
\item What about deep/nested sharing?
\item Examples (exRecList, ...)
\end{itemize}


\chapter{Call-Time Choice modelled in Coq}
\label{ch:callTimeChoiceCoq}
The goal of this chapter is to transfer the Haskell implementation of call-time choice to Coq.
We begin with the data structure \hinl{Prog}, that is, the free monad, which allowed us to model programs with effects of type \hinl{sig} and results of type \hinl{a}.

\begin{minted}{Haskell}
data Prog sig a = Return a | Op (sig (Prog sig a))
\end{minted}

The definition in Coq looks very similar to the Haskell version, aside from renaming and the explicit constructor types.

\begin{minted}{Coq}
Inductive Free F A :=
| pure : A -> Free F A
| impure : F (Free F A) -> Free F A.
\end{minted}

However, the definition is rejected by Coq upon loading the file with the following error message.

\begin{minted}{Text}
Non-strictly positive occurrence of "Free" in "F (Free F A) -> Free F A".
\end{minted}

The reason for this error is explained in the next section.

\section{Non-strictly Positive Occurrence}
\begin{itemize}
\item What does non-strictly positive occurrence mean?
\item Motivation for usage of containers
\end{itemize}

In \autoref{sec:coqIntro}, we learned that Coq distinguishes between non-recursive definitions and functions that use recursion.
The reason for this is that Coq checks functions for termination, which is an important part of Coq's proof logic.
To understand why functions must always terminate in Coq, we consider the following function.

% https://www.di.ens.fr/~zappa/teaching/coq/ecole11/summer/lectures/lec9.pdf
\begin{minted}{Coq}
Fail Fixpoint loop (x : unit) : A := loop x.
\end{minted}

The function receives an argument \mintinline{Coq}{x} and calls itself with the same argument.
Since this function obviously never terminates, the result type \mintinline{Coq}{A} is arbitrary.
In particular, we could instantiate \mintinline{Coq}{A} with \mintinline{Coq}{False}, the false proposition.
The value \mintinline{Coq}{loop tt : False} could be used to prove anything, according to the principle of explosion.
For this reason, Coq requires all recursive functions to terminate provably.

Returning to the original data type, what is link between \mintinline{Coq}{Free} and termination?
It is well known that recursion can be implemented in languages without explicit recursion syntax by means of constructs like the Y combinator or the data type \mintinline{Coq}{Mu} for type-level recursion.

\begin{minted}{Coq}
Fail Inductive Mu A := mu : (Mu A -> A) -> Mu A.
\end{minted}

\mintinline{Coq}{Mu} is not accepted by Coq for the same reason as \mintinline{Coq}{Free}: non-strictly positive occurrence of the respective data type.
The problematic property of non-strictly positive data types is that the type occurs on the left-hand side of a constructor argument's function type.
This would allow general recursion and thus, as described above, make Coq's logic inconsistent.

In case of \mintinline{Coq}{Free}, the non-strictly positive occurrence is not as apparent as before because the constructors do not have functional arguments.
However, \mintinline{Coq}{F} is being applied to \mintinline{Coq}{Free F A}.
If \mintinline{Coq}{F} has a functional argument with appropriate types, the resulting type becomes non-strictly positive, as shown below.

\begin{minted}{Coq}
Definition Cont R A := (A -> R) -> R.

(* Free (Cont R) *)
Fail Inductive ContF R A :=
| pureC   : A -> ContF R A
| impureC : ((ContF R A -> R) -> R) -> ContF R A.
\end{minted}

In the type of \mintinline{Coq}{impureC} contains a non-strictly positive occurrence of \mintinline{Coq}{ContF R A}.
Consequently, Coq rejects \mintinline{Coq}{Free} because it is not guaranteed that no instance violates the strict positivity requirement.
Representing the \mintinline{Coq}{Free} data type therefore requires a way to restrict the definition to strictly positive data types.
One approach to achieve this goal is described in the next section.

\section{Containers}

\begin{itemize}
\item How do containers work?
\item How do we translate effect functors into containers?
\end{itemize}

Containers are an abstraction of data types that store values, with the property that only strictly positive data types can be modelled as a container.
This will allow us to define a version of \mintinline{Coq}{Free} that works with containers of type constructors instead of the type constructors itself.
First, however, we will have a more detailed look at containers.

The first component of a container is the type \mintinline{Coq}{Shape}.
A shape determines how the data type is structured, regardless of the stored values.
For example, the  shape of a list is the same as the shape of Peano numbers: a number that  represents the length of the list, or rather the number of \hinl{Cons}/\hinl{Succ} applications.
A pair, on the other hand, has only a single shape.

The second component of a container is a function \mintinline{Coq}{Pos : Shape -> Type} that gives each shape a type that represents the positions within the shape.
In the example of pairs, the shape has two positions, the first and second component.
Each element of a list is a position within the shape.
Therefore, the position type for lists with length $n$ is natural numbers smaller than $n$.
Peano numbers do not have elements and therefore, the position type for each shape is empty.

Containers can be extended by a function that maps all valid positions to values.
Since the position type depends on a concrete shape, the definition in Coq is quantified universally over values of type \mintinline{Coq}{Shape}.

\begin{minted}{Coq}
Inductive Ext Shape (Pos : Shape -> Type) A := 
  ext : forall s, (Pos s -> A) -> Ext Shape Pos A.
\end{minted}

The extension of a container models the concrete data type.

\section{Modelling Effects}
\begin{itemize}
\item In which ways is the Coq implementation simplified, compared to Haskell?
\item How does the adapted Prog/sig infrastructure work?
\item How do we translate recursive functions?
\end{itemize}

\section{Sharing}
\label{sec:lawsOfSharing}
\begin{itemize}
\item Laws of sharing
\end{itemize}

\chapter{Curry Programs modelled in Coq}
\begin{itemize}
\item Can we use the Coq model of call-time choice to prove properties about actual Curry programs?
\end{itemize}

\chapter{Conclusion}

\begin{minted}{Coq}

  Class Monad (M: Type → Type) ≔
    {
      ret : ∀ A, A → M A;
      bind : ∀ A B, M A → (A → M B) → M B;
      left_unit : ∀ A B (x0: A) (f: A → M B),
                    bind (ret x0) f = f x0;
      right_unit : ∀ A (ma: M A), bind ma (@ret A) = ma;
      bind_assoc: ∀ A B C (ma : M A) (f: A → M B) (g: B → M C),
                    bind ma (fun y ⇒ bind (f y) g) = bind (bind ma f) g
    }.

  Definition join (M: Type → Type) `(Monad M) A (mmx : M (M A)) : M A ≔ bind _ mmx (fun x ⇒ x).

End MonadClass.
Arguments join {_} {_} {_}.

Section MonadInstance.

  Variable F : Type → Type.
  Variable C__F : Container F.


\end{minted}


% Literatur
\bibliographystyle{plainnat}
\bibliography{Mathesis} % Datei: seminar.bib
% Anhang
\appendix
\end{document}